!function(o){function r(n){if(e[n])return e[n].exports;var t=e[n]={i:n,l:!1,exports:{}};return o[n].call(t.exports,t,t.exports,r),t.l=!0,t.exports}var e={};r.m=o,r.c=e,r.d=function(o,e,n){r.o(o,e)||Object.defineProperty(o,e,{configurable:!1,enumerable:!0,get:n})},r.n=function(o){var e=o&&o.__esModule?function(){return o.default}:function(){return o};return r.d(e,"a",e),e},r.o=function(o,r){return Object.prototype.hasOwnProperty.call(o,r)},r.p="",r(r.s=3)}([function(o,r,e){r.render=function(){function o(){var o,c,u;i=document.getElementById("glscreen"),i.addEventListener("mousemove",function(o){f=r(i,o)},!1),t=i.getContext("experimental-webgl"),i.width=640,i.height=480,a=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,a),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),t.STATIC_DRAW),t.viewport(0,0,t.drawingBufferWidth,t.drawingBufferHeight),o=e(1),c=t.createShader(t.VERTEX_SHADER),t.shaderSource(c,o),t.compileShader(c),o=e(2),u=t.createShader(t.FRAGMENT_SHADER),t.shaderSource(u,o),t.compileShader(u),program=t.createProgram(),t.attachShader(program,c),t.attachShader(program,u),t.linkProgram(program),t.useProgram(program),n()}function r(o,r){var e=o.getBoundingClientRect();return{x:r.clientX-e.left,y:e.bottom-r.clientY}}function n(){window.requestAnimationFrame(n,i),positionLocation=t.getAttribLocation(program,"a_position"),t.enableVertexAttribArray(positionLocation),t.vertexAttribPointer(positionLocation,2,t.FLOAT,!1,0,0),mousePosition=t.getUniformLocation(program,"mouse"),t.uniform2f(mousePosition,f.x/i.width,f.y/i.height),resolutionPosition=t.getUniformLocation(program,"resolution"),t.uniform2f(resolutionPosition,i.width,i.height),timePosition=t.getUniformLocation(program,"time"),t.uniform1f(timePosition,((new Date).getTime()-c)/1e3),offsetPosition=t.getUniformLocation(program,"offset"),t.uniform2f(offsetPosition,-.023500000000000434,.9794000000000017),pitchPosition=t.getUniformLocation(program,"pitch"),t.uniform2f(pitchPosition,50,50),t.drawArrays(t.TRIANGLES,0,6)}var t,i,a,f={x:0,y:0},c=(new Date).getTime();window.onload=o}},function(o,r){o.exports="attribute vec2 a_position;\r\n  void main() {\r\n    gl_Position = vec4(a_position, 0, 1);\r\n  }"},function(o,r){o.exports="#define NUM_STEPS   50\r\n  #define ZOOM_FACTOR 2.0\r\n  #define X_OFFSET    0.5\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nuniform vec2 offset; // e.g. [-0.023500000000000434 0.9794000000000017], currently the same as the x/y offset in the mvMatrix\r\nuniform vec2 pitch;  // e.g. [50 50]\r\n\r\nvoid main() {\r\n  float lX = gl_FragCoord.x / resolution.x;\r\n  float lY = gl_FragCoord.y / resolution.y;\r\n\r\n  float scaleFactor = 10000.0;\r\n\r\n  float offX = (scaleFactor * offset[0]) + gl_FragCoord.x;\r\n  float offY = (scaleFactor * offset[1]) + (1.0 - gl_FragCoord.y);\r\n\r\n  if (int(mod(offX, pitch[0])) == 0 ||\r\n      int(mod(offY, pitch[1])) == 0) {\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.5);\r\n  } else {\r\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n  }\r\n}"},function(o,r,e){e(4),e(0),e(1),o.exports=e(2)},function(o,r,e){e(0).render()}]);